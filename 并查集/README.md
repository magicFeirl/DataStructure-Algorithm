# 并查集

用来判断两点之间是否有关系，下次碰到这种题就不会抓瞎了。

常见题型举例：帮派问题、族谱问题等。

## 加权

现在有两个根节点P、Q需要连接，为了优化查询时间，我们总是将小树连接到大树上，这样可以减少搜索的深度。为此需要新开一个数组用来保存树中的节点数，在每次连接前我们先判断对应树的大小，然后根据先前的思想将小树连到大树上（把小树的根指向大树的根），最后将小树的节点数增加到大树的节点数中。

```c++
if(sz[p] > sz[q]){
    id[q] = id[p];
    sz[p] += sz[q];
}else{
    id[p] = id[q];
    sz[q] += sz[p];
}
```

## 路径压缩

对于一个结点P，我们要找到其的根，就是要找到结点值等于下标值的结点（`id[p] == p`)，如果只是简单地使用一个循环：

```c++
// 循环版找根
while(p != id[p]){
    p = id[p];
}

// 递归版找根
int find(int p){
    if(p != id[p]){
        return find(id[p]);
    }
   	return id[p];
}
```

在树的深度过大的情况下效率会很低下。

为此我们可以使用递归，将根节点下每个节点的结点值更新为其父节点的值，如此理想情况下只需要一次搜索。总体思路和上面的递归类似，不过是多加了一个赋值操作。

```c++
int find(int p){
	if(id[p] != p){
		id[p] = find(id[p]);
	}
	
	return id[p];
}
```

